import pandas as pd

'''
В реальных проектах данные обычно не хранятся в одной таблице. Вместо нее используется много маленьких. 
С помощью нескольких таблиц данными легче управлять, проще избегать «многословия», можно экономить место на диске, 
а запросы к таблицам обрабатываются быстрее.

Суть в том, что при работе с данными довольно часто придется вытаскивать данные из двух разных таблиц. 
Это делается с помощью функции: merge

Рассмотрим пример. Для этого необходимо взять DataFrame который мы использовали ранее. 
В нём хранятся данные о мебели (её цена, название, код). Но в этот раз нужен еще один DataFrame —  fur_quantity, 
в котором будет отображено количество мебели в наличии каждого вида.
'''
fur = pd.DataFrame({'furniture': ['chair', 'chair', 'chair', 'table', 'table', 'table', 'table', 'table', 'bed', 'bed',
                                  'bed', 'bed', 'bed', 'bed', 'bed', 'sofa', 'sofa', 'sofa', 'sofa'],
        'uniq_id': [1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016,
                    1017, 1018, 1019],
        'price': [1000, 600, 550, 300, 320, 330, 290, 310, 200, 220, 240, 230, 220, 100, 80, 420,
                    600, 500, 390]})
print(f"датафрейм fur:\n{fur}\n")

fur_quantity = pd.DataFrame({'furniture': ['table', 'bed', 'sofa', 'cupboard'], 'quantity': [13, 12, 5, 10]})

print(f"датафрейм fur_quantity:\n{fur_quantity}\n")

# Для того чтобы объединить два эти Data Frames необходимо использовать функцию:
print(f"fur.merge(fur_quantity):\n{fur.merge(fur_quantity)}\n")

'''
Данная функция объединяет две таблицы по общим полям. В нашем случае поле furniture является общим,
а поле quantity добавляется к исходному DataFrame.
'''
print(f"fur.merge(fur_quantity) == fur_quantity.merge(fur)\n"
      f"разница будет лишь в порядке колонок в финальной таблице:"
      f"\n{fur_quantity.merge(fur)}\n")

'''
Базовый метод merge довольно прост. Но иногда к нему нужно добавить несколько параметров.

Функция merge работает по аналогии с функцией JOIN из SQL.
При выборе INNER JOIN объединяются только те значения, которые можно найти в обеих таблицах. В случае же с OUTER JOIN 
объединяются все значения, даже если некоторые из них есть только в одной таблице.

Конкретный пример: в fur_quantity нет значения chair, а в fur нет cupboard. По умолчанию использовался метод INNER, 
поэтому и daybed, и commode пропали из таблицы. 
Но бывают случаи, когда нужно, чтобы все значения оставались в объединенном DataFrame. 
Этого можно добиться следующим образом:
'''
print(f"fur.merge(fur_quantity, how='outer'):\n{fur.merge(fur_quantity, how='outer')}\n")

'''
В этот раз все строки отображены в таблице. Но поскольку вторая таблица не предоставила конкретных данных, 
то вместо значения ставится пропуск (NaN).
Если вам необходимо вывести информацию только из одной таблицы, вы можете воспользоваться левосторонним или 
правосторонним соединением, в таком случае вы можете воспользоваться параметром how='left' 
или how='rigth', соответственно. Ниже представлен пример для левостороннего соединения:
'''
print(f"fur.merge(fur_quantity, how='left'):\n{fur.merge(fur_quantity, how='left')}\n")

'''
Таким образом, how = 'left' заберет все значения из левой таблицы, но из правой  использует только те значения, 
которые есть в левой.

Если вам необходимо заменить значение NaN на любое другое нужное вам используйте :
'''
print(f"fur.merge(fur_quantity, how='left').fillna('unknown'):\n"
      f"{fur.merge(fur_quantity, how='left').fillna('unknown')}\n")

'''
Для использования merge библиотеке pandas нужны ключевые колонки, на основе которых будет проходить объединение, 
в случае с примером это колонка furniture. Иногда pandas не сможет распознать их автоматически, и тогда нужно указать 
названия колонок. Для этого нужны параметры left_on и right_on.

Например, последний merge мог бы выглядеть следующим образом:
'''
print(f"fur.merge(fur_quantity, how='left', left_on='furniture', right_on ='furniture'):\n"
      f"{fur.merge(fur_quantity, how='left', left_on='furniture', right_on ='furniture')}\n")

# ---------------------------------------------------------------------------------------------------------------------
'''
Сортировка — последовательное расположение или разбиение на группы чего-либо в зависимости от выбранного критерия.
Базовый метод сортировки в pandas совсем не сложный. Функция называется sort_values()
И работает она следующим образом:
'''
print('Сортировка\n')
print(f"fur_quantity.sort_values('quantity'):\n{fur_quantity.sort_values('quantity')}\n")

'''
После сортировки возникают проблемы с нумерацией, неправильная индексация может испортить визуализацию или 
повлиять на то, как работают модели машинного обучения.
В случае изменения DataFrame нужно переиндексировать строки. Для этого можно использовать метод:
reset_index()

Также с помощью параметра ascending указывается тип сортировки, в примере представленном ниже сортировка по убыванию.
'''
print(f"fur_quantity.sort_values(by=['quantity'], ascending=False).reset_index():\n"
      f"{fur_quantity.sort_values(by=['quantity'], ascending=False).reset_index()}\n")

'''
Новый DataFrame также хранит старые индексы. 
Если они не нужны, их можно удалить с помощью параметра drop=True в функции:
'''
print(f"fur_quantity.sort_values(by=['quantity'], ascending=False).reset_index(drop=True):\n"
      f"{fur_quantity.sort_values(by=['quantity'], ascending=False).reset_index(drop=True)}\n")
